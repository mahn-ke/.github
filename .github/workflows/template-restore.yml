# Required environment variables:
# - RESTIC_ROOT:  Directory where restic repositories should be stored
#
# Required binaries/tools:
# - restic (https://restic.net/)

name: Restore

on:
  workflow_call:
    inputs:
      date:
        description: 'Either restore snapshot before this date (YYYY-MM-DDTHH:MM:SS format, optional)'
        required: false
        type: string
      tag:
        description: 'Or restore latest backup with this tag (optional)'
        required: false
        type: string

jobs:
  select_snapshots:
    outputs:
      VOLUMES: ${{ steps.volumes.outputs.VOLUMES }}
      SNAPSHOTS: ${{ steps.volumes.outputs.SNAPSHOTS }}
      TIMESTAMP: ${{ steps.volumes.outputs.TIMESTAMP }}
    runs-on: hetzner2
    env:
      RESTIC_PASSWORD: ${{ secrets.RESTIC_PASSWORD }}
    steps:
      - name: Check RESTIC_ROOT is set
        run: |
          if (-not $env:RESTIC_ROOT) {
            Write-Host "RESTIC_ROOT is not set"
            exit 1
          }
        shell: pwsh

      - name: Ensure either date or tag is provided
        run: |
          $date = "${{ github.event.inputs.date }}".Trim()
          $tag = "${{ github.event.inputs.tag }}".Trim()
          if (-not $date -and -not $tag) {
            Write-Host "Either provide the closest date to restore from or a tag to restore"
            exit 1
          }
        shell: pwsh
        
      - name: Set environment variables and RESTIC_REPOSITORY
        run: |
          $REPO_NAME = Split-Path $env:GITHUB_REPOSITORY -Leaf
          $PROJECT_NAME = $REPO_NAME -replace '-by-vincent', ''
          Add-Content -Path $env:GITHUB_ENV -Value "RESTIC_REPOSITORY=$env:RESTIC_ROOT\$PROJECT_NAME"
          Add-Content -Path $env:GITHUB_ENV -Value "PROJECT_NAME=$PROJECT_NAME"
        shell: pwsh
        
      - name: Find snapshots for each volume
        id: volumes
        run: |
          # Find volumes to restore
          docker compose config | Out-File -FilePath config.yml -Encoding utf8
          $mappings = docker run --rm -v "${PWD}:/workdir" mikefarah/yq ".services[].volumes[].source" config.yml
          $unique_mappings = $mappings | Sort-Object | Get-Unique
          $volumes = $unique_mappings | Where-Object { $_ -notmatch '[\\/]' }
          Add-Content -Path $env:GITHUB_OUTPUT -Value "VOLUMES=$($volumes -join ',')"
          Write-Host "Volumes to restore:`n$($volumes -join "`n")"

          # Find snapshots to restore from
          $repo = "$env:RESTIC_REPOSITORY"
          $date = "${{ github.event.inputs.date }}"
          $tag = "${{ github.event.inputs.tag }}"

          $snapshotsByVolume = @{}
          $selectedSnapshotsByVolume = @{}
          foreach ($volume in $volumes) {
            $snapshotsByVolume[$volume] = restic -r $repo snapshots --path "/$volume" --json | ConvertFrom-Json
            if ($tag) {
              $filtered = $snapshotsByVolume[$volume] | Where-Object { $_.tags -contains $tag }
              $snapshot = $filtered | Sort-Object -Property time -Descending | Select-Object -First 1
              if (-not $snapshot) {
                Write-Host "No snapshot found for volume $(($env:PROJECT_NAME))_${volume} with tag $tag"
                continue
              }
              Write-Host "Using snapshot id $($snapshot.short_id) with tag $tag for volume $(($env:PROJECT_NAME))_${volume} ($($snapshot.time)) (tags: $($snapshot.tags -join ', ')))"
              $selectedSnapshotsByVolume[$volume] = $snapshot
              continue
            }

            if ($date) {
              $target = [datetime]::Parse($date)
              $snapshot = $snapshotsByVolume[$volume] | Sort-Object { [datetime]$_.time } | `
              Where-Object { [datetime]$_.time -le $target } | Select-Object -Last 1
              if (-not $snapshot) {
                Write-Host "No snapshot found for volume $(($env:PROJECT_NAME))_${volume} before $date"
                continue
              }
              Write-Host "Using snapshot id $($snapshot.short_id) closest to $date for volume $(($env:PROJECT_NAME))_${volume} ($($snapshot.time)) (tags: $($snapshot.tags -join ', '))"
              $selectedSnapshotsByVolume[$volume] = $snapshot
              continue
            }

            Write-Host "No matching snapshot found for volume $(($env:PROJECT_NAME))_${volume}"
          }

          $latestSnapshot = $selectedSnapshotsByVolume.Values | Sort-Object { [datetime]$_.time } | Select-Object -Last 1
          if (!$latestSnapshot) {
            Write-Host "At least one snapshot must be found matching the tag; exiting"
            exit 1
          }
          
          $missingVolumes = $volumes | Where-Object { -not $selectedSnapshotsByVolume.ContainsKey($_) }
          foreach ($mv in $missingVolumes) {
            Write-Host "Finding closest snapshot for volume $(($env:PROJECT_NAME))_${mv}."
            $snapshots = restic -r $repo snapshots --path "/$mv" --json | ConvertFrom-Json
            $snapshot = $snapshots | Sort-Object { [datetime]$_.time } | Where-Object { [datetime]$_.time -le [datetime]$($latestSnapshot.time) } | Select-Object -Last 1
            if (-not $snapshot) {
              Write-Host "No snapshot found for volume $(($env:PROJECT_NAME))_${mv} before $($latestSnapshot.time); exiting"
              exit 2
            }

            Write-Host "Using snapshot id $($snapshot.short_id) closest to latestSnapshot ($($latestSnapshot.time)) for volume $(($env:PROJECT_NAME))_${mv} ($($snapshot.time)) (tags: $($snapshot.tags -join ', '))"
            $selectedSnapshotsByVolume[$mv] = $snapshot
          }

          # for all volumes, print all available snapshot ID and time, and prefix selected with `>`
          foreach ($volume in $volumes) {
            Write-Host ""
            Write-Host "------------------------------"
            Write-Host "Available snapshots for volume $(($env:PROJECT_NAME))_${volume}:"
            foreach ($s in $snapshotsByVolume[$volume] | Sort-Object { [datetime]$_.time }) {
              $prefix = if ($s.short_id -eq $selectedSnapshotsByVolume[$volume].short_id) { '>' } else { ' ' }
              $tagsPart = if ($s.tags -and $s.tags.Count -gt 0) { " (tags: $($s.tags -join ', '))" } else { "" }
              Write-Host "$prefix $($s.short_id) $($s.time)$tagsPart"
            }
            Write-Host "------------------------------"
          }

          Add-Content -Path $env:GITHUB_OUTPUT -Value "SNAPSHOTS=$($snapshot_ids -join ',')"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "TIMESTAMP=$(Get-Date -Format 'yyyyMMdd-HHmmss')"
        shell: pwsh
        
  # can't be part of `backup`, as shared workflows can't use `environment`, which triggers approvals
  confirm:
    needs: [select_snapshots]
    environment: production
    runs-on: ubuntu-latest
    steps:
      - name: Confirm restore
        run: |
          echo "Confirmed"
      
  backup:
    needs: [confirm, select_snapshots]
    uses: mahn-ke/.github/.github/workflows/template-backup.yml@main
    secrets: inherit
    with:
      tags: prerestore_${{ needs.select_snapshots.outputs.TIMESTAMP }}

  restore:
    needs: [backup, select_snapshots]
    runs-on: hetzner2
    env:
      RESTIC_PASSWORD: ${{ secrets.RESTIC_PASSWORD }}
    steps:
      - name: Set environment variables and RESTIC_REPOSITORY
        run: |
          $REPO_NAME = Split-Path $env:GITHUB_REPOSITORY -Leaf
          $PROJECT_NAME = $REPO_NAME -replace '-by-vincent', ''
          Add-Content -Path $env:GITHUB_ENV -Value "RESTIC_REPOSITORY=$env:RESTIC_ROOT\$PROJECT_NAME"
          Add-Content -Path $env:GITHUB_ENV -Value "PROJECT_NAME=$PROJECT_NAME"
        shell: pwsh

      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Shut down docker compose
        env:
          COMPOSE_PROJECT_NAME: ${{ env.PROJECT_NAME }}
        run: docker compose down
        shell: pwsh

      - name: Delete all volume content
        run: |
          $volumes = "${{ needs.select_snapshots.outputs.VOLUMES }}".Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }

          $volumes | ForEach-Object {
            $volume = $_
            Write-Host "Deleting content of volume: $(($env:PROJECT_NAME))_${volume}"
            docker run --rm -i --mount "source=$(($env:PROJECT_NAME))_${volume},target=/data" alpine sh -c "rm -rf /data/*"
          }
        shell: pwsh

      - name: Restore each volume to temp directory and copy into volume
        run: |
          $volumes = "${{ needs.select_snapshots.outputs.VOLUMES }}".Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }
          $snapshots = "${{ needs.select_snapshots.outputs.SNAPSHOTS }}".Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }
          if ($volumes.Count -ne $snapshots.Count) {
            Write-Host "Number of volumes and snapshots do not match: $($volumes.Count) volumes, $($snapshots.Count) snapshots"
            exit 1
          }

          $i = 0
          $volumes | ForEach-Object {
            $volume = $_
            $tmp = Join-Path $env:TEMP ([guid]::NewGuid().ToString())
            mkdir $tmp | Out-Null
            Write-Host "Restoring $(($env:PROJECT_NAME))_${volume} to $tmp"
            restic -r "$env:RESTIC_REPOSITORY" restore --path "/$volume" $($snapshots[$i]) --target "$tmp" --include "/"
            Write-Host "Copying restored data to $(($env:PROJECT_NAME))_${volume}"
            docker run --rm `
              -v "${tmp}:/from" `
              -v "$(($env:PROJECT_NAME))_${volume}:/to" `
              alpine sh -c "cp -a /from/${volume}/. /to/"
            Remove-Item -Recurse -Force $tmp
            $i++
          }
        shell: pwsh

  deploy:
    needs: restore
    uses: mahn-ke/.github/.github/workflows/template-deploy.yml@main
    secrets: inherit
