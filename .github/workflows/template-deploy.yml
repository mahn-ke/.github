# Required environment variables:
# - NGINX_HOME: Directory containing nginx.exe (https://nginx.org/)
# - ACME_HOME:  Directory containing wacs.exe (https://www.win-acme.com/)
# - CERT_HOME:  Directory containing certificates generated by ACME
#
# Required binaries/tools:
# - docker
# - docker compose

name: Deploy service, generate certificates, and update NGINX configuration

on:
  workflow_call:

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Check for Dockerfile
        id: check_dockerfile
        run: |
          if [ -f app/Dockerfile ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Dockerfile found in app directory."
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "No Dockerfile found in app directory."
          fi

      - name: Log in to GitHub Container Registry
        if: steps.check_dockerfile.outputs.exists == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Docker image
        if: steps.check_dockerfile.outputs.exists == 'true'
        run: |
          docker build -t ghcr.io/${{ github.repository }}:latest .
        working-directory: app

      - name: Push Docker image
        if: steps.check_dockerfile.outputs.exists == 'true' && github.event_name != 'pull_request'
        run: |
          docker push ghcr.io/${{ github.repository }}:latest
        working-directory: app

  prepare-postgres:
    runs-on: ubuntu-latest
    outputs:
      DATABASE_NAME: ${{ steps.ensure-db.outputs.DATABASE_NAME }}
      PROJECT_NAME: ${{ steps.ensure-db.outputs.PROJECT_NAME }}
    steps: 
      - name: Ensure database exists
        id: ensure-db
        env:
           PGHOST: ${{ secrets.PGHOST }}
           PGPORT: ${{ secrets.PGPORT }}
           PGUSER: ${{ secrets.PGUSER }}
           PGPASSWORD: ${{ secrets.PGPASSWORD }}
           PGDATABASE: "postgres"
        run: |
          REPO_NAME="$(basename "$GITHUB_REPOSITORY")"
          DATABASE_NAME="$(echo "$REPO_NAME" | sed 's/-by-vincent//' | tr '-' '.')"
          echo "DATABASE_NAME=$DATABASE_NAME" >> $GITHUB_OUTPUT
          PROJECT_NAME="$(echo "$REPO_NAME" | sed 's/-by-vincent//')"
          echo "PROJECT_NAME=$PROJECT_NAME" >> $GITHUB_OUTPUT

          for suffix in infrastructure service; do
            db="${DATABASE_NAME}-$suffix"
            exists="$(psql -tAc "SELECT 1 FROM pg_database WHERE datname = '$db'")"
            if [ "$exists" = "1" ]; then
              echo "Database '$db' already exists."
              continue
            fi
            createdb "$db"
            if [ $? -ne 0 ]; then
              echo "Failed to create database '$db'."
              exit 1
            fi
            echo "Database '$db' created."
          done

  infrastructure-terraform-plan:
    needs: prepare-postgres
    runs-on: ubuntu-latest
    env:
      PGDATABASE: ${{ needs.prepare-postgres.outputs.DATABASE_NAME }}-infrastructure
    outputs:
      exitcode: ${{ steps.plan.outputs.exitcode }}
      HAS_DOCKER_COMPOSE: ${{ steps.check-docker-compose.outputs.HAS_DOCKER_COMPOSE }}
    steps:
      - name: Expose GitHub environment as shell variables
        env:
          SECRETS_CONTEXT: ${{ toJson(secrets) }}
        run: |
          # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable
          # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings
          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          to_envs() { jq -r "to_entries[] | \"\(.key)<<$EOF\n\(.value)\n$EOF\n\""; }
          echo "$SECRETS_CONTEXT" | to_envs >> $GITHUB_ENV
          
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - run: terraform version

      - run: terraform init
        working-directory: infrastructure

      - name: exit if terraform fmt is not clean
        run: |
          if ! terraform fmt -check -recursive; then
            echo "Terraform files are not formatted correctly. Please run 'terraform fmt' to fix them."
            exit 1
          fi
        working-directory: infrastructure


      - name: terraform plan
        id: plan
        continue-on-error: true
        run: | 
          terraform plan -input=false --out=tfplan --detailed-exitcode
        working-directory: infrastructure

      - name: Check if Terraform apply is required
        run: |
          echo "exitcode: ${{ steps.plan.outputs.exitcode }}"
          
          if [ "${{ steps.plan.outputs.exitcode }}" == "1" ]; then
            echo "Error running terraform; see logs above"
            exit 1
          fi
          
          if [ "${{ steps.plan.outputs.exitcode }}" == "0" ]; then
            echo "Configuration files found but no changes; skipping apply"
            exit 0
          fi
          
          if grep -q "No configuration files" <<<"${{ steps.plan.outputs.stderr }}"; then
            echo "No configuration files found; skipping apply"
            exit 0
          fi

          echo "Configuration files found and changes; running apply"
        working-directory: infrastructure

      - name: Upload Terraform plan
        if: steps.plan.outputs.exitcode == 2
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-infrastructure
          path: infrastructure/tfplan

      - name: Check for docker-compose.yml
        id: check-docker-compose
        run: |
          if [ ! -f "docker-compose.yml" ]; then
            echo "HAS_DOCKER_COMPOSE=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "HAS_DOCKER_COMPOSE=true" >> $GITHUB_OUTPUT

  infrastructure-terraform-apply:
    runs-on: ubuntu-latest
    env:
      PGDATABASE: ${{ needs.prepare-postgres.outputs.DATABASE_NAME }}-infrastructure
    environment: production
    needs: [prepare-postgres, infrastructure-terraform-plan]
    if: needs.infrastructure-terraform-plan.outputs.exitcode == 2 && github.event_name != 'pull_request'
    steps:
      - name: Expose GitHub environment as shell variables
        env:
          SECRETS_CONTEXT: ${{ toJson(secrets) }}
        run: |
          # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable
          # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings
          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          to_envs() { jq -r "to_entries[] | \"\(.key)<<$EOF\n\(.value)\n$EOF\n\""; }
          echo "$SECRETS_CONTEXT" | to_envs >> $GITHUB_ENV

      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - run: terraform version
          
      - run: terraform init
        working-directory: infrastructure

      - name: Download Terraform plan
        uses: actions/download-artifact@v5
        with:
          name: tfplan-infrastructure
          path: infrastructure

      - run: terraform apply -input=false -auto-approve tfplan
        working-directory: infrastructure

  deploy:
    runs-on: hetzner2
    if: ${{ !cancelled() && needs.infrastructure-terraform-plan.outputs.HAS_DOCKER_COMPOSE == 'true' && github.event_name != 'pull_request' }}
    needs: [build, prepare-postgres, infrastructure-terraform-plan, infrastructure-terraform-apply]
    steps:
      - name: fail if any previous step failed
        if: needs.prepare-postgres.result == 'failure' || needs.infrastructure-terraform-plan.result == 'failure' || needs.infrastructure-terraform-apply.result == 'failure'
        run: exit 1

      - name: Expose GitHub environment as shell variables
        env:
          SECRETS_CONTEXT: ${{ toJson(secrets) }}
        run: |
          # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable
          # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings
          $EOF = [System.Guid]::NewGuid().ToString("N").Substring(0,16)
          $secrets = $env:SECRETS_CONTEXT | ConvertFrom-Json
          foreach ($pair in $secrets.PSObject.Properties) {
            Add-Content -Path $env:GITHUB_ENV -Value "$($pair.Name)<<$EOF`n$($pair.Value)`n$EOF"
          }

      - name: Checkout current repository to src (with submodules)
        uses: actions/checkout@v5
        with:
          path: src
          submodules: recursive

      - name: Checkout mahn-ke/.github to workflow
        uses: actions/checkout@v5
        with:
          repository: mahn-ke/.github
          path: workflow 
      
      - name: Check versions
        run: | 
          docker version
          docker compose version
          nginx -v
        working-directory: src

      - name: Run Docker Compose
        env:
          COMPOSE_PROJECT_NAME: ${{ needs.prepare-postgres.outputs.PROJECT_NAME }}
        run: docker compose up -d --pull always
        working-directory: src

      - name: Attempt subdomain deployment, if required
        run: ../workflow/tools/Deploy.ps1
        shell: pwsh
        working-directory: src

  service-terraform-plan:
    needs: [prepare-postgres, deploy]
    runs-on: ubuntu-latest
    if: ${{ !cancelled() }}
    env:
      PGDATABASE: ${{ needs.prepare-postgres.outputs.DATABASE_NAME }}-service
    outputs:
      exitcode: ${{ steps.plan.outputs.exitcode }}
      HAS_DOCKER_COMPOSE: ${{ steps.check-docker-compose.outputs.HAS_DOCKER_COMPOSE }}
    steps:
      - name: fail if any previous step failed
        if: needs.prepare-postgres.result == 'failure' || needs.deploy.result == 'failure'
        run: exit 1

      - name: Expose GitHub environment as shell variables
        env:
          SECRETS_CONTEXT: ${{ toJson(secrets) }}
        run: |
          # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable
          # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings
          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          to_envs() { jq -r "to_entries[] | \"\(.key)<<$EOF\n\(.value)\n$EOF\n\""; }
          echo "$SECRETS_CONTEXT" | to_envs >> $GITHUB_ENV
          
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - run: terraform version

      - run: terraform init
        working-directory: service

      - name: exit if terraform fmt is not clean
        run: |
          if ! terraform fmt -check -recursive; then
            echo "Terraform files are not formatted correctly. Please run 'terraform fmt' to fix them."
            exit 1
          fi
        working-directory: service

      - name: terraform plan
        id: plan
        continue-on-error: true
        run: | 
          terraform plan -input=false --out=tfplan-service --detailed-exitcode
        working-directory: service

      - name: Check if Terraform apply is required
        run: |
          echo "exitcode: ${{ steps.plan.outputs.exitcode }}"
          
          if [ "${{ steps.plan.outputs.exitcode }}" == "1" ]; then
            echo "Error running terraform; see logs above"
            exit 1
          fi
          
          if [ "${{ steps.plan.outputs.exitcode }}" == "0" ]; then
            echo "Configuration files found but no changes; skipping apply"
            exit 0
          fi
          
          if grep -q "No configuration files" <<<"${{ steps.plan.outputs.stderr }}"; then
            echo "No configuration files found; skipping apply"
            exit 0
          fi

          echo "Configuration files found and changes; running apply"
        working-directory: service

      - name: Upload Terraform plan
        if: steps.plan.outputs.exitcode == 2
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-service
          path: service/tfplan

  service-terraform-apply:
    runs-on: ubuntu-latest
    env:
      PGDATABASE: ${{ needs.prepare-postgres.outputs.DATABASE_NAME }}-service
    environment: production
    needs: [prepare-postgres, service-terraform-plan, deploy]
    if: needs.service-terraform-plan.outputs.exitcode == 2
    steps:
      - name: Expose GitHub environment as shell variables
        env:
          SECRETS_CONTEXT: ${{ toJson(secrets) }}
        run: |
          # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable
          # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings
          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          to_envs() { jq -r "to_entries[] | \"\(.key)<<$EOF\n\(.value)\n$EOF\n\""; }
          echo "$SECRETS_CONTEXT" | to_envs >> $GITHUB_ENV

      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - run: terraform version
          
      - run: terraform init
        working-directory: service

      - name: Download Terraform plan
        uses: actions/download-artifact@v5
        with:
          name: tfplan-service
          path: service

      - run: terraform apply -input=false -auto-approve tfplan
        working-directory: service
